# An anatomy of agents

## A brief history

The concept of the “software agent” can be traced back to the model Carl Hewitt proposed: a self-contained, interactive, and concurrently executing object which was called an “actor.” This object had some encapsulated internal state and could respond to messages from other similar objects. By Hewitt’s definition, an actor “is a computational agent which has a mail address and a behaviour. Actors communicate by message-passing and carry out their actions concurrently.” (Hewitt, 1977).

The notion of agency (the designation that something can go and independently carry out multiple actions concurrently) evolved into the concept of intelligent agents, agents that used AI to perform some complex decision-making. However, these agents were still of lower capability, as they made tactical decisions at various points in a workflow without keeping in mind the notion of some larger goal. Then came autonomous agents, which maintained larger goals, could sense their environment, and could react to the state of that environment in order to progress towards their goal.

Among the earliest definitions of an autonomous agent was that of Franklin and Graesser (1997), “An autonomous agent is a system situated within and a part of an environment that senses that environment and acts on it, over time, in pursuit of its own agenda and so as to effect what it senses in the future.”

## Defining Characteristics

Agents have been defined in various ways and have been a point of discussion for some time, especially since the introduction of LLMs. It is always useful to have one encompassing definition that is extensible as well as expressive, building on commonly understood concepts from the past. For the definition of our notion of an “agent object,” we refer to basic principles embodying an agent, and we use them to develop the agent object in the world of LLMs. In order to be able to program them scalably to build robust systems, an agent object must have the principles of:

1. **Autonomy:** An agent is an autonomous, interactive entity with its own state, behavior, and decision-making capabilities

2. **Reactivity and Proactivity:** Agents are both reactive, meaning they can perceive their environment and respond to changes, and proactive, meaning they can take initiative based on their goals.

3. **Beliefs, Desires, and Intentions (BDI):** A common model used in AOP is the BDI model, where agents are characterized by their beliefs (information about the world), desires (goals or objectives), and intentions (plans of action).

4. **Social Ability & Communication:** Agents have a communication mechanism and can interact with other agents or entities in their environment. This interaction can be highly complex as it may involve negotiation, coordination, and cooperation.

5. **Self-Improvement:** Agents have an innate desire to maximize their utility and hence self-improve themselves on the task they were created for.

6. **Security:** An agent needs to protect itself from being compromised or destroyed as well as be trustworthy to not harm other agents and the environment they are operating in.

<img src="https://github.com/EmergenceAI/EmergenceAI.github.io/blob/main/_posts/_images/AOM.png" width="500">

*Pictured above: Agent Object Model.*

## Agent-Oriented Programming

Programming paradigms such as Object Oriented Programming (OOP) evolved from the need to design and develop code that was highly reusable, maintainable, and scalable. Simula, a programming language which came out in the 60s, is generally thought to be the first OOP language. However, it was not until the 80s that the use of OOP concepts to develop large-scale enterprise-class software became common, with the introduction of C++ (80s) and later Java (90s). Even though COBOL and FORTRAN were extremely popular in the 70s for enterprise software, their key strengths were in accounting (COBOL) and scientific programming (FORTRAN) but not in acting as general-purpose OOP languages. The true power and deployment of OOP software in enterprise came to the forefront with the advent of Java and Java Beans.

Similarly, we are on the cusp of another evolution in programming paradigms with LLM-driven systems that have the potential to completely change enterprise workflows. Recently, the technical community has been primarily dabbling in advanced experiments with LLM-driven systems. Now, with the validation of enterprise-scale possibilities, we need to extend the current Agent-Oriented Programming (AOP) paradigms to include the power and capabilities of the LLMs. These include capabilities as discussed above, such as advanced language understanding, communication with humans as well as other agents, self-improvement, various methods of “reasoning” (CoT, ToT, ReACT etc.), the ability to personalize and take advantage of context from Long Term Memory (LTM), and the ability to sense and interpret their environment and act on it through the use of tools. Several programming languages and frameworks have been developed specifically for AOP, such as AgentSpeak, JACK, and Jade. These tools provide structures and paradigms for creating agent-based systems but do not capture the new concepts of AOP that have been made possible by LLMs. AOP is particularly useful in complex systems where individual components need to operate independently and interact in sophisticated ways, such as in multi-agent systems.

|               |                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|               | **Object Oriented Programming**                                                                                                                                                                                                                                                                                            | **Agent-Oriented Programming**                                                                                                                                                                                                                                                                                                                                                                                             |
| Encapsulation | Helps set boundaries of _Data_ and _Methods_ to help wrap related data, and methods that act on that data, into one single entity called an _Object_. Encapsulation makes code highly scalable and reusable, and it gives us objects whose data are self-contained along with the operations that can happen on that data. | Similarly involves bundling the data (like the state of the environment) and the methods that operate on the data (like decision-making algorithms) into a single unit, or agent. Each agent in a system can maintain its state and behavior, allowing for modular and maintainable code. For example, in a multi-agent simulation, each agent can have its own set of properties and behaviors encapsulated as an object. |
| Abstraction   | Focuses on the high-level strategy of problem-solving rather than the details. Abstraction helps create better system design by hiding from the user implementation details that may not be relevant at a particular level or that can’t be revealed for intellectual property reasons.                                    | Similarly, can mean designing a general-purpose algorithm (like a search algorithm or a reinforcement learning policy) that can be applied to various specific problems. This high-level approach allows AI developers to work with complex concepts without getting bogged down in every detail of implementation.                                                                                                        |
| Inheritance   | An extremely powerful concept that helps in code reuse and extensibility as well as in better human understanding of the developed code.                                                                                                                                                                                   | Allows new AI agents to be created using the characteristics of existing ones. This is particularly useful in hierarchical AI systems, where more specialized agents can inherit common features from more general agents. For example, a general agent class might include basic sensory and action capabilities, while a more specialized agent class inherits these and adds additional, more specific capabilities.    |
| Polymorphism  | Primarily refers to the concepts of overloading and overriding. Overloading is used to improve the readability of the code while overriding is used to change the inherited behavior of the parent class.                                                                                                                  | Refers to the ability of different agent classes to be treated as instances of a parent class. This is particularly useful in scenarios where different types of agents might be needed, but they can all be interacted with uniformly. For instance, different kinds of robotic agents (like drones, ground vehicles, etc.) might have unique abilities but share common interfaces for control and data gathering.       |

To enable efficient programming of agent-based systems, some of the base characteristics of an agent need to be available as superclass templates for developers to derive from and reuse rapidly, also allowing them to maintain a semblance of uniformity in how agents are defined and programmed. AutoGen (2023) is an example of an agent communication and collaboration paradigm which has made it extremely easy to build multi-agent collaboration systems. However, many more base characteristics of agents need to be standardized and frameworks built to enable large-scale agent-oriented programming paradigms. Some of these are as shown in the figure below.

<img src="https://github.com/EmergenceAI/EmergenceAI.github.io/blob/main/_posts/_images/class.png" width="1000">

In conclusion, developing the right abstractions for agent-oriented programming is very important to ensure we can build systems that scale and have reusable components. We believe that building this framework is going to be an extremely complex endeavor, and the best way to build it is in the open-source community. We will be doing our part by releasing pieces of this larger framework into the community in the hopes of rallying like-minded developers to contribute to the project. In our next blog, we will delve deeper into self-improvement, a fundamental characteristic of an agent if it is to have agency and the ability to measure itself against its beliefs and goals.

**References**

1. Hewitt, C. (1977), “Viewing Control Structures as Patterns of Passing Messages”, Artificial Intelligence 8(3), 323-364.

2. Franklin, S. and Graesser, A. (1997) Is It an Agent, or Just a Program? A Taxonomy for Autonomous Agents, In: Müller, J.P., Wooldridge, M.J. and Jennings, N.R., Eds., Intelligent Agents III Agent Theories, Architectures, and Languages, Springer, Berlin Heidelberg, 21-35.

3. Wu, Q., Bansal, G., Zhang, J., Wu, Y., Zhang, S., Zhu, E., ... & Wang, C. (2023). Autogen: Enabling next-gen llm applications via multi-agent conversation framework. _arXiv preprint arXiv:2308.08155_.
